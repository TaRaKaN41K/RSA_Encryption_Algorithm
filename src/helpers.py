import random
import math


# Функция для нахождения наибольшего общего делителя (НОД) с использованием алгоритма Евклида
def gcd(a: int, b: int) -> int:
    """
    Рассчитывает наибольший общий делитель (НОД) двух целых чисел с использованием алгоритма Евклида.

    Параметры:
    a (int): Первое целое число.
    b (int): Второе целое число.

    Возвращает:
    int: Наибольший общий делитель чисел a и b.
    """
    while b != 0:
        a, b = b, a % b  # Обновляем значения a и b согласно алгоритму Евклида
    return a


# Функция для проверки, является ли число простым
def isprime(num: int) -> bool:
    """
    Проверяет, является ли данное число простым.

    Параметры:
    num (int): Число для проверки.

    Возвращает:
    bool: True, если число простое, иначе False.
    """
    # Если число меньше 2, оно не может быть простым
    if num < 2:
        return False
    # Проверяем делители от 2 до квадратного корня из числа
    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:  # Если число делится на i, оно не простое
            return False
    return True  # Если делителей не найдено, число простое


# Функция для нахождения мультипликативного обратного числа с использованием расширенного алгоритма Евклида
def multiplicative_inverse(number: int, module: int) -> int | None:
    """
    Вычисляет мультипликативное обратное число для 'number' по модулю 'module' с использованием расширенного алгоритма Евклида.

    Этот метод используется для нахождения обратного числа в криптографических операциях, например, в алгоритме RSA.

    Параметры:
    number (int): Число, для которого нужно найти мультипликативное обратное.
    module (int): Модуль.

    Возвращает:
    int | None: Мультипликативное обратное число для 'e' по модулю 'phi', если оно существует, иначе None.
    """
    d, x1, x2, y1 = 0, 0, 1, 1  # Инициализация переменных для расширенного алгоритма Евклида
    temp_phi = module  # Сохраняем значение phi для дальнейших вычислений
    while number > 0:  # Пока значение e больше нуля
        temp1, temp2 = temp_phi // number, temp_phi - (temp_phi // number) * number  # Частное и остаток
        # Обновление коэффициентов для поиска обратного
        x, y = x2 - temp1 * x1, d - temp1 * y1
        temp_phi, number, x2, x1, d, y1 = number, temp2, x1, x, y1, y  # Перенос значений для следующей итерации
    # Если остаток равен 1, то обратное число существует, и оно хранится в переменной d
    return d + module if temp_phi == 1 else None


# Функция для генерации случайного простого числа
def generate_prime_number() -> int:
    """
    Генерирует случайное простое число.

    Эта функция генерирует случайные целые числа в пределах указанного диапазона
    и проверяет, является ли число простым, используя функцию isprime(). Процесс продолжается,
    пока не будет найдено простое число.

    Возвращает:
    int: Случайное простое число в диапазоне от 100 до 500,000,000 (включительно).
    """
    while True:
        num = random.randint(100, 500000000)  # Генерируем случайное число в диапазоне от 100 до 500,000,000
        if isprime(num):  # Если число простое
            return num  # Возвращаем это число


# Функция для вычисления квадратного корня с использованием численного метода
def manual_exponentiation(base: int, exp: int, mod: int) -> int:
    result = 1
    for _ in range(exp):
        result = (result * base) % mod
    return result


def fast_exponentiation(base: int, exp: int, mod: int) -> int:
    """
    Выполняет быстрое возведение в степень base^exp по модулю mod.

    Параметры:
    base (int): Основание степени.
    exp (int): Показатель степени.
    mod (int): Модуль.

    Возвращает:
    int: Результат возведения в степень base^exp по модулю mod.
    """
    result = 1
    base = base % mod  # Уменьшаем base, если оно больше mod
    while exp > 0:
        # Если exp нечетное, умножаем результат на текущее значение base
        if exp % 2 == 1:
            result = (result * base) % mod
        # Обновляем exp и base для следующей итерации
        exp = exp // 2  # Делим exp на 2
        base = (base * base) % mod  # Удваиваем base
    return result
